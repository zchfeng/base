## [爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)

### 动态规划解法

```
var climbStairs = function(n) {
   let dp = [];
   dp[0] = 0;
   dp[1] = 1;
   dp[2] = 2;
   for (let index = 3; index <= n; index++) {
     dp[index] = dp[index - 1] + dp[index - 2];
   }

   return dp[n];
}
```

### 递归解法

```
function climbStairs3(n) {
  if (n <= 2) {
    return n;
  }

  return climbStairs3(n - 1) + climbStairs3(n - 2);
}

```

## [最长递增子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)

```
var lengthOfLIS = function(nums) {
    let length = nums.length
    let dp = Array.from({length},()=> 1)
    let maxLength = 1
    for(let i=1; i<length; i++){
        for(let j=0;j<i;j++){
            if(nums[i]>nums[j]){
                dp[i] = Math.max(dp[j]+1,dp[i])
            }
        }
     maxLength = Math.max(dp[i],maxLength)
    }
    return maxLength
};
```
