## 栈 - 后进先出

```
class Stack {
  constructor() {
    this.item = [];
  }
  // 向栈顶添加元素
  push(value) {
    this.item.push(value);
  }
  // 向栈顶删除元素-返回删除元素
  pop() {
    return this.item.pop();
  }
  // 返回栈顶元素-不改变栈
  peek() {
    return this.item[this.item.length - 1];
  }
  // 判断栈内有无元素
  isEmpty() {
    return !!this.item.length;
  }
  // 返回栈内元素个数
  size() {
    return this.item.length;
  }
  // 清空栈
  clean() {
    this.item = [];
  }
}

```

## 队列 - 先进先出

```
class Queue {
  constructor() {
    this._items = [];
  }
  //  向队列尾部添加元素
  enqueue(value) {
    this._items.push(value);
  }
  //   移除队列第一项（最前面的项），返回移除的元素
  dequeue() {
    return this._items.shift();
  }
  // 返回队列最前面（第一）的项
  head() {
    return this._items[0];
  }
  // 返回队列最后面的项
  tail() {
    return this._items[this._items.length - 1];
  }
  //   判断队列有无元素
  isEmpty() {
    return !!this._items.length;
  }
  //   返回对应元素个数
  size() {
    return this._items.length;
  }
  //   清空队列
  clear() {
    this._items = [];
  }
}
```

### leetcode-225. 用队列实现栈

```
var MyStack = function() {
    this.queue1 = new Queue()
    this.queue2 = new Queue()
    this.currentQ = this.queue1
};

/**
 * @param {number} x
 * @return {void}
 */
MyStack.prototype.push = function(x) {
    if(!this.queue1.isEmpty()){
        this.queue1.enqueue(x)
        while(this.queue2.isEmpty()){
            this.queue1.enqueue(this.queue2.dequeue())
        }
        this.currentQ = this.queue1
    }else{
        this.queue2.enqueue(x)
        while(this.queue1.isEmpty()){
            this.queue2.enqueue(this.queue1.dequeue())
        }
        this.currentQ = this.queue2
    }

};

/**
 * @return {number}
 */
MyStack.prototype.pop = function() {
    return this.currentQ.dequeue()
};

/**
 * @return {number}
 */
MyStack.prototype.top = function() {
   return this.currentQ.head()
};

/**
 * @return {boolean}
 */
MyStack.prototype.empty = function() {
    console.log(this.currentQ,this)
   return !this.currentQ.isEmpty()
};
```

### leetcode-232. 用栈实现队列

```
var MyQueue = function() {
    this.stack1 = new Stack()
    this.stack2 = new Stack()
};

/**
 * @param {number} x
 * @return {void}
 */
MyQueue.prototype.push = function(x) {
    if(this.stack2.isEmpty() && !this.stack1.isEmpty()){
        while(this.stack2.isEmpty()){
            this.stack1.push(this.stack2.pop())
        }
    }
    this.stack1.push(x)
};

/**
 * @return {number}
 */
MyQueue.prototype.pop = function() {
    while(this.stack1.isEmpty()){
        this.stack2.push(this.stack1.pop())
    }
    return this.stack2.pop()
};

/**
 * @return {number}
 */
MyQueue.prototype.peek = function() {
    while(this.stack1.isEmpty()){
        this.stack2.push(this.stack1.pop())
    }
    return this.stack2.peek()
};

/**
 * @return {boolean}
 */
MyQueue.prototype.empty = function() {
    if(this.stack2.isEmpty()&& !this.stack1.isEmpty()){
        while(this.stack2.isEmpty()){
            this.stack1.push(this.stack2.pop())
        }
    }
    return !this.stack1.isEmpty()
};
```
